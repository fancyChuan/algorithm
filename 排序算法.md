## 排序算法

#### 1.冒泡排序
- 描述：重复从序列右边开始比较相邻两个数字的大小，根据比较结果交换连个数字的位置
- 时间复杂度：O(n^2)
    - 第一轮需要比较n-1次，此时最左边的值最小/最大
    - 第二轮需要比较n-2次，此时第二左边的值第二小/第二大

#### 2.选择排序
- 描述：重复“从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换”。在序列中寻找最小是使用到的是线性查找
- 时间复杂度：O(n^2)
    - 第一轮需要比较n-1次，第2论需要比较n-2个数字
    
#### 3. 插入排序
- 思路：从右侧未排序区域中取出一个数据，然后将其插入到已排序区域内合适的位置上
- 时间复杂度：O(n^2)
    - 首先先假设最左边的数字已经排好序，之后从第2个数字开始依次和最左边的数字比较
    - 最左边的数字大则交换位置，否则就把第2个数字放到最左边

#### 4. 堆排序
- 描述：利用了数据结构中的堆
- 时间复杂度：O(nlogn)
    - 首先在堆中存储所有的数据，使用降序来构建堆
    - 从堆中把所有数据一个个取出来反序输出（每次取出需要重新构早堆）

#### 5. 归并排序
- 描述：把序列分成长度相同的两个子序列，当无法继续往下分的时候（子序列只有一个元素），就对子序列进行归并。归并是指把两个排好序的子序列合并成一个有序序列
- 时间复杂度：O(nlogn)
    - 合并的时候，首先先比较首位数字，把小的那一个放到上一级，之后继续比较首位数字，依次类推
    - 特点：合并完成，序列也排好序了
    
#### 6. 快速排序
- 描述：在序列中随机选择一个基准值，然后其他数字分位“比基准值大”和“比基准值小”两个类别。之后再对两边的序列采取同样的方式
- 时间复杂度：O(nlogn)或者O(n^2)
    - 这是一种“分治法”，把问题分成两个子问题，然后再解决两个子问题


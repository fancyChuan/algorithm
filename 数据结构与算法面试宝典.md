## 数据结构与算法面试宝典 学习笔记

#### 做算法题的方法论
四步分析法：
- 模拟：模拟题目的运行。
- 规律：尝试总结出题目的一般规律和特点。
- 匹配：找到符合这些特点的数据结构与算法。
- 边界：考虑特殊情况。

进一步思考：
- 深度扩展：这种解法是否还能优化
- 广度扩展：这种解法是否有普适性，是否可以推广

### 1.简单栈：先进后出，后进先出
栈的特性
```
Stack<Character> t = new Stack<Character>();
t.push('a');
t.push('b');
t.peek(); // 这里得到栈顶元素'b'
t.pop();  // 这里将栈顶元素'b'弹出
t.peek(); // 此时栈顶元素为'a'
t.pop();  // 这里将栈顶元素'a'弹出
```

示例：（参考代码 [StackSolution.java](src/main/java/lagou/model1/StackSolution.java)）
- 示例1：判断字符串括号是否合法
- 示例2：大鱼吃小鱼
- 示例3：找出数组中右边第一个比我小的元素
> TODO: 如何从线性的思维（双重for循环）跳到使用栈的思维？？
- 示例4：字典序最小的 k 个数的子序列
```
【题目】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。

输入：nums = [3,5,2,6], k = 2
输出：[2,6]

解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。
```
> 注意这个题目中，子序列要求是“依次”取出的，因此不会出现[2,3]这样的组合，否则这个[2,3]的字典序才是最小的


单调栈
- 有序性：“任何时候都需要保证栈的有序性”
    - 递增栈
    - 递减栈
- 单调栈也是有消除行为的

总结：
- 从示例1到示例4，可以分析从简单栈到单调栈，层层推进的过程中，不停变化就是入栈与出栈的时机。

### 2.队列
```
Queue 中 add() 和 offer()都是用来向队列添加一个元素。
在容量已满的情况下，add() 方法会抛出IllegalStateException异常，offer() 方法只会返回 false 。
```
#### 2.1先入先出队列FIFO
FIFO 有两个点：
- push元素时，总是将元素放到队列的尾部
- pop元素时，总是将队列首部的元素扔掉

题目：
##### 例 1：二叉树的层次遍历（两种方法）
> 当你发现题目具备广度遍历（分层遍历）和顺序输出的特点，就应该想到用FIFO 队列来试一试
- 思考题
![image](leetcode/images/题目：填充二叉树的next指针.png)
- 其他关于层次遍历的变体：[题目及解题思路](https://github.com/lagoueduCol/Algorithm-Dryad/blob/main/02.Queue/README.md)


关于二叉树的边界：遇到空二叉树时，有2种解决思路
- 特殊判断：如果发现是空二叉树，直接返回空结果
- 制定一个规则：不让空指针进入FIFO队列

FIFO 队列不仅可以用 Queue 表示，还可以用两层 ArrayList 来表示，均可达到同样的效果

##### 例2：循环队列
**所有的循环数组下标的处理都需要按照这个取模方法来**
```
index = i 的后一个 (i + 1) % capacity
index = i 的前一个(i - 1 + capacity) % capacity
```

在多线程编程里面，控制变量越少，越容易实现无锁编程，因此，在无锁队列里面，利用方法 2 较容易实现无锁队列。

**使用java实现循环队列的两种方式**
- 方法1：使用used变量 [CircularQueue1](src/main/java/nn2/injava/CircularQueue1.java)
- 方法2：只使用front和rear来实现 [CircularQueue2](src/main/java/nn2/injava/CircularQueue2.java)


#### 2.2 单调队列
单调队列属于双端队列的一种。双端队列与 FIFO 队列的区别在于：
- FIFO 队列只能从尾部添加元素，首部弹出元素；
- 双端队列可以从首尾两端 push/pop 元素。

单调队列在入队的时候，需要满足 2 点：
- 入队前队列已经满足单调性；
- 入队后队列仍然满足单调性。
> 特别之处：
> 每次入队的时候，为了保证队列的单调性，还要剔除掉尾部的元素。直到尾部的元素大于等于入队元素（因为是单调递减队列）。
> 
> 出队时，需要给出一个 value，如果 value 与队首相等，才能将这个数出队

单调递减队列最重要的特性是：**入队与出队的组合，可以在 O(1) 时间得到某个区间上的最大值。**

#### 2.3 优先级队列
通常而言，优先级队列都是基于堆（Heap）这种数据结构来实现的

堆的特点：大堆的根是最大值，小堆的根是最小值

堆的表示：大部分时候都是使用数组表示一个堆，而不是使用二叉树。这是因为:
- 数组的内存具有连续性，访问速度更快；
- 堆结构是一棵完全二叉树。


## 数据结构与算法面试宝典 学习笔记

#### 做算法题的方法论
四步分析法：
- 模拟：模拟题目的运行。
- 规律：尝试总结出题目的一般规律和特点。
- 匹配：找到符合这些特点的数据结构与算法。
- 边界：考虑特殊情况。

进一步思考：
- 深度扩展：这种解法是否还能优化
- 广度扩展：这种解法是否有普适性，是否可以推广

### 简单栈：先进后出，后进先出
栈的特性
```
Stack<Character> t = new Stack<Character>();
t.push('a');
t.push('b');
t.peek(); // 这里得到栈顶元素'b'
t.pop();  // 这里将栈顶元素'b'弹出
t.peek(); // 此时栈顶元素为'a'
t.pop();  // 这里将栈顶元素'a'弹出
```

示例：
- 示例1：判断字符串括号是否合法
- 示例2：大鱼吃小鱼
- 示例3：找出数组中右边第一个比我小的元素
> TODO: 如何从线性的思维（双重for循环）跳到使用栈的思维？？
- 示例4：字典序最小的 k 个数的子序列
```
【题目】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。

输入：nums = [3,5,2,6], k = 2
输出：[2,6]

解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。
```
> 注意这个题目中，子序列要求是“依次”取出的，因此不会出现[2,3]这样的组合，否则这个[2,3]的字典序才是最小的


单调栈
- 有序性：“任何时候都需要保证栈的有序性”
    - 递增栈
    - 递减栈
- 单调栈也是有消除行为的

总结：
- 从示例1到示例4，可以分析从简单栈到单调栈，层层推进的过程中，不停变化就是入栈与出栈的时机。

### 队列
```
Queue 中 add() 和 offer()都是用来向队列添加一个元素。
在容量已满的情况下，add() 方法会抛出IllegalStateException异常，offer() 方法只会返回 false 。
```
#### 先入先出队列FIFO
FIFO 有两个特点：
- push元素时，总是将元素放到队列的尾部
- pop元素时，总是将队列首部的元素扔掉

题目：
- 例 1：二叉树的层次遍历（两种方法）
> 当你发现题目具备广度遍历（分层遍历）和顺序输出的特点，就应该想到用FIFO 队列来试一试
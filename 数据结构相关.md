## 数据结构
简单来说，数据结构所描述的是一种辅助程序设计并进行优化的方法论
- 讨论数据的存储和处理的方法
- 也考虑数据彼此之间的关系和运算
- 目的：提高程序的执行效率和减少对内存空间的占用等

数据 ——处理——> 信息（具有参考价值）

数据结构+算法：是指数据进入计算机内进行处理的一整套流程

#### 1.链表Linked List
随机存储，通过指针访问下一个元素

#### 2.数组Array
- 数组是是一组具有相同的名称和数据类型的元素的集合，并使用连续分配的内存空间来存储有序表中的数据
- 是一种典型的静态数据结构
- 与链表相比，在特定位置添加或者删除元素的成本很高

> 静态数据结构：在编译时就给相关的变量分配好内存空间

#### 3.栈
- 先进后出（后进先出）
- 入栈push，出栈pop
- 只在一端做操作，在只需要访问最新数据时，比较方便

#### 4.队列
- 先进先出

#### 5. 哈希表
- 存储的是由key/value组成的数据，具有存储上的灵活性和查询上的高效性
- 制作hash表的过程
    - 对目标数据求hash值
    - 求得的hash值对表的容量取模。比如我们大小为6的数组作为hash表，那么就是：hash mod 6 得到的值表示存入相应的位置
    - 当位置发生冲突时，使用链表继续存储
    - 查找时，通过hash mod 6 得到的结果表示在相应的位置上，取出该位置上的链表进行一一对比

> 链地址法：在存储数据的过程中，如果发生冲突，可以利用链表在已知数据后面插入新数据来解决冲突

> 其他解决冲突的方法：
> - 开放地址法：当冲突发生时，立刻计算出一个候补地址（数组上的位置）并将数据存入，如果有冲突则计算下一个。可以通过多次使用hash函数或者线性探测法等方法计算候补地址

#### 6. 堆
- 堆是一种图的树形结构，被用于实现“优先队列”
- 节点内的数字就是存储的数据，堆中的每个节点最多有两个子节点
- 节点的排列顺序为从上到下，同一行从左到右
- 存储数据时必须遵守的规则：子节点的值必须大于父节点
    - 为了遵守这条规则，一般会把新数据放在最下面一行靠左的位置。当最下面一个行没有多余空间的时候就往下另起一行
    - 不满足规则时，则需要交换父子节点的位置。（需要重复这样的操作直到所有节点都满足规则）
- 取数据的特点：
    - 堆中最顶端的数据始终最小，取出最小值的时间复杂度为O(1)
    - 取出最顶端的数据后，需要将最后的数据移到最顶端，然后比较子节点不断调整至最终满足规则要求
    - 取出数据后重构树的时间复杂度为O(logn)。添加数据也一样，复杂度跟树的高度成正比
- 使用场景：频繁的需要从数据中取出最小值，比如狄克斯特拉算法

#### 7. 二叉查找树（也叫二叉搜索树/二叉排序树）
- 也采用了图的树形结构
- 每个节点最多有两个子节点
- 有两个性质：
    - 每个节点的值均大于其左子树上任意一个结点的值
    - 每个节点的值均小于其右子树上任意一个结点的值
- 结论：
    - 二叉查找树的最小结点要从顶端开始往其左下的末端寻找
    - 二叉查找树的最大结点要从顶端开始往其右下的末端寻找
- 添加数据时：从顶点开始一次比较，小于则左移，大于则右移
- 删除数据时：
    - 没有任何子节点时直接删除
    - 有一个子结点时，先删除，再把子结点填充到原来的位置
    - 同时有左右两个子节点时，先删除，再在被删除结点的左子树中寻找最大结点，把最大结点移到被删除结点的位置上。如果最大结点下面还有子结点，则继续递归执行前面的操作
- 查找元素：比较结点，小则左移，大则右移。如果树的结构比较均衡，那么时间复杂度为O(logn)。如果树的形状单侧纵向延伸，那么时间复杂度就变为了O(n)
> 补充说明
> - 我们可以不把二叉查找树当作是二分查找算法的树形实现
> - 有很多以二叉查找树为基础扩展的数据结构，比如平衡二叉查找树。这种结构可以修正形状不均衡的数据，让其保持平衡
> - 二叉查找树的子结点数可以拓展为m。像子结点数可以自由设定并且形状均衡的树就是B树



这时什么鬼
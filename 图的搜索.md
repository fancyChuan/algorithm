## 图的搜索

加权图、有向图、无向图

> 没有闭环的图称为数

#### 1. 广度优先搜索
从顶点开始，设置下一级的候选顶点。之后优先选择最早成为候补的那个顶点（先进先出，可以使用队列）。选择之后判断是否为终点，否的话在设置下一级候选点。

#### 2. 深度优先搜索
使用栈这种数据结构


#### 3. 贝尔曼-福特算法
这是一种在图中求解最短路径问题的算法，需要对所有的边都重复计算权重和更新权重

有负数时可以直接认定不存在最短路径，但是狄克斯特拉算法则会得出一个错误的最短路径。（TODO：为什么？为什么这个算法可以认定不存在最短路径？）

顶点数为n、边数为m，时间复杂度为O(nm)

#### 4. 狄克斯特拉算法
也是求解最短路径问题的算法，只是多了一步选择顶点的操作（根据起点到候选顶点的距离来决定下一个顶点），使得在求最短路径上更高效。



顶点数为n、边数为m：
- 如果不实现进行任何处理，那么时间复杂度为O(n^2)
- 对数据结构进行优化，那么时间复杂度就变为O(m+nlogn)

> 贝尔曼-福特算法在权重存在负数的时候同样可以求解，而狄克斯特拉算法则不行


#### 5. A*算法（A-star算法）
跟狄克斯特拉算法相比，A*会预先估计一个值，并利用这个值省去一些无用的计算

应用：
- 经常被用在游戏编程中计算敌人追赶玩家时的行动路线（但由于该算法计算量较大，所以实际使用时会考虑结合其他算法）